/** **************************************************************************************************************
 * Map generation engine ("Minecraft à la carte" service from IGN)
 * Generate sandbox games maps with geo data from IGN
 * ***************************************************************************************************************
 * Copyright (c) Institut national de l'information géographique et forestière
 * This program and the accompanying materials are made available under the terms of the GPL License, Version 3.0.
 * ***************************************************************************************************************/

package ign.minecraft.importer;

import java.awt.Composite;
import java.awt.CompositeContext;
import java.awt.RenderingHints;
import java.awt.image.ColorModel;
import java.awt.image.DataBuffer;
import java.awt.image.Raster;
import java.awt.image.WritableRaster;
import java.nio.file.Path;

import ign.minecraft.MinecraftGenerationException;

/**
 * 
 * this class extends the drawing capabitilities of WSFFluxLoader
 * by giving the possibility of defining the pixel color merging operation
 * 
 * subclass must define the blendColors method
 *
 */
public abstract class ColorTreatmentVectorLoader extends VectorLoader {
	
	protected final class CustomBlendComposite implements Composite {
		private final ColorTreatmentVectorLoader fluxLoader;
		
		public CustomBlendComposite(ColorTreatmentVectorLoader fluxLoader) {
			this.fluxLoader = fluxLoader;
		}
		
		public CompositeContext createContext(ColorModel srcColorModel, ColorModel dstColorModel,
				RenderingHints hints) {
			return new CustomBlendContext(fluxLoader);
		}

		/*
		 * the composite context class that really makes the pixel operations
		 * it will call the Flux loader to get the blend value
		 */
		private final class CustomBlendContext implements CompositeContext {
			private final ColorTreatmentVectorLoader fluxLoader;

			private CustomBlendContext(ColorTreatmentVectorLoader fluxLoader) {
				this.fluxLoader = fluxLoader;
				
				//TODO : get color models in constructor and
				//	assert color models are the ones the code has been made for (src = int ARGB, and dest = 4 bytes RGBA)
				//	( strangely enough, the raster generated by drawing primitives has int values
				//	although the graphics we draw on has byte values )
				//	we could also adapt the code depending on the color models but it seems a lot of work
				//	and not very useful in our case
			}

			public void dispose() {
			}

			public void compose(Raster src, Raster dstIn, WritableRaster dstOut) {
	            assert (src.getSampleModel().getDataType() == DataBuffer.TYPE_INT &&
	                    dstIn.getSampleModel().getDataType() == DataBuffer.TYPE_BYTE &&
	                    dstOut.getSampleModel().getDataType() == DataBuffer.TYPE_BYTE);
				
				int width = Math.min(src.getWidth(), dstIn.getWidth());
				int height = Math.min(src.getHeight(), dstIn.getHeight());

	            int[] srcPixels = new int[width];
	            byte[] dstPixels = new byte[width*4];

				int pixelValueA, pixelValueB, pixelValueG, pixelValueR, srcPixelValueARGB, dstPixelValueARGB;
				for (int y = 0; y < height; y++ ) {
	                src.getDataElements(0, y, width, 1, srcPixels);
	                dstIn.getDataElements(0, y, width, 1, dstPixels);
					for (int x = 0; x < width; x++ ) {
						srcPixelValueARGB = srcPixels[x];

						pixelValueR = (int) dstPixels[x * 4] & 0xff;
						pixelValueG = (int) dstPixels[x * 4 + 1] & 0xff;
						pixelValueB = (int) dstPixels[x * 4 + 2] & 0xff;
						pixelValueA = (int) dstPixels[x * 4 + 3] & 0xff;
						dstPixelValueARGB = (pixelValueA << 24) + (pixelValueR << 16) + (pixelValueG << 8) + pixelValueB;

						if (dstPixelValueARGB != 0) {
							pixelValueA = 0;
						}
						//let the flux loader decide for the color result
						dstPixelValueARGB = fluxLoader.blendColors(srcPixelValueARGB, dstPixelValueARGB );
						//set destination pixel bytes
						dstPixels[x * 4] = (byte) ((dstPixelValueARGB >> 16) & 0xff);//R
						dstPixels[x * 4 + 1] = (byte) ((dstPixelValueARGB >> 8) & 0xff);//G
						dstPixels[x * 4 + 2] = (byte) (dstPixelValueARGB & 0xff);//B
						dstPixels[x * 4 + 3] = (byte) ((dstPixelValueARGB >> 24) & 0xff);//A
					}
	                dstOut.setDataElements(0, y, width, 1, dstPixels);
				}
			}
		}
	}

	public ColorTreatmentVectorLoader(double realworldSquareSize, double realworldCenterLong, double realworldCenterLat,
			int pixelMapSize, Path resourcesPath) throws MinecraftGenerationException {
		this(realworldSquareSize, realworldCenterLong, realworldCenterLat, pixelMapSize, resourcesPath, true);
	}

	public ColorTreatmentVectorLoader(double realworldSquareSize, double realworldCenterLong, double realworldCenterLat,
			int pixelMapSize, Path resourcesPath, boolean setComposite) throws MinecraftGenerationException {
		super(realworldSquareSize, realworldCenterLong, realworldCenterLat, pixelMapSize, resourcesPath);

		if (setComposite) {
			// set composite mode to default graphic buffer
			graphics.setComposite(new CustomBlendComposite(this));
		}
	}
	
	/**
	 * 
	 * @param srcPixelValueRGB
	 * @param dstPixelValueRGB
	 * @return blended RGB pixel value
	 */
	public abstract int blendColors( int srcPixelValueARGB, int dstPixelValueARGB);

}
